var documenterSearchIndex = {"docs":
[{"location":"","page":"MPSGE","title":"MPSGE","text":"CurrentModule = MPSGE_MP","category":"page"},{"location":"#MPSGE","page":"MPSGE","title":"MPSGE","text":"","category":"section"},{"location":"","page":"MPSGE","title":"MPSGE","text":"Documentation for MPSGE.","category":"page"},{"location":"","page":"MPSGE","title":"MPSGE","text":"This is a test","category":"page"},{"location":"","page":"MPSGE","title":"MPSGE","text":"","category":"page"},{"location":"","page":"MPSGE","title":"MPSGE","text":"Modules = [MPSGE_MP]","category":"page"},{"location":"#MPSGE_MP.build!-Tuple{MPSGEModel}","page":"MPSGE","title":"MPSGE_MP.build!","text":"build!(M::MPSGEModel)\n\nCurrently, I'm creating the variables when the sector is added to the model. However, I think we can do this here without issue. I would prefer doing it here.\n\n\n\n\n\n","category":"method"},{"location":"#MPSGE_MP.extract_scalars-Tuple{MPSGE_MP.MPSGEScalarVariable}","page":"MPSGE","title":"MPSGE_MP.extract_scalars","text":"extract_scalars\n\nTakes a variable and extracts it the sub-variables. \n\n\n\n\n\n","category":"method"},{"location":"#MPSGE_MP.production_sectors-Tuple{MPSGEModel}","page":"MPSGE","title":"MPSGE_MP.production_sectors","text":"production_sectors(m::MPSGEModel)\n\nReturn all sectors that have a corresponding production block.  These are coming from a dictionary, so order is not guaranteed.\n\nThis is primarily used when generating constraints.\n\n\n\n\n\n","category":"method"},{"location":"#MPSGE_MP.sectors-Tuple{Commodity}","page":"MPSGE","title":"MPSGE_MP.sectors","text":"sectors(C::Commodity)\n\nReturn only the sectors that have the input commodity in their production block. \n\nThis is an optimization in building the model as the structure is very sparse  iterating over all sectors is expensive.\n\n\n\n\n\n","category":"method"},{"location":"#MPSGE_MP.sectors-Tuple{MPSGEModel}","page":"MPSGE","title":"MPSGE_MP.sectors","text":"sectors(m::MPSGEModel)\n\nReturn all sectors in a model\n\n\n\n\n\n","category":"method"},{"location":"#MPSGE_MP.solve!-Tuple{MPSGE_MP.AbstractMPSGEModel}","page":"MPSGE","title":"MPSGE_MP.solve!","text":"solve!(m::abstract_mpsge_model; keywords)\nFunction to solve the model. Triggers the build if the model hasn't been built yet.\n\nExample\n\njulia> solve!(m, cumulative_iteration_limit=0)\n\n\n\n\n\n","category":"method"},{"location":"how_it_works/#How-MPSGE-Works","page":"How MPSGE Works","title":"How MPSGE Works","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Work in progress","category":"page"},{"location":"how_it_works/#Constructing-Equations","page":"How MPSGE Works","title":"Constructing Equations","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Consider a production block on sector S. This block will have an input tree and output tree. The generated equations are different for inputs vs outputs.  However, they only differ up to a sign in certain locations. Let  $ \\epsilon = \\left{\\begin{array}{cl}     -1 & \\text{Tree is input} \\\n     1 & \\text{Tree is output} \\end{array}\\right. $ represent this sign. ","category":"page"},{"location":"how_it_works/#Compensated-Demand","page":"How MPSGE Works","title":"Compensated Demand","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Consider a netput tree containing a single nest and k commodities as in the  Figure below. ","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"(Image: \"one_level_tree\")","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Each commodity node has a reference price p_i, quantity Q_i, variable C_i,  and taxes t_ih, where the index h is a consumer. Let q_i = Q_icdot p_i  represent the reference quantity of each commodity node n_i, then q = sum q_i  be the quantity of the root n. The root also has an elasticity sigma.","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"The cost function for the commodity node n_i will be given by pi_nn_i where $ \\pi{n,Ci} = \\frac{C{ni}(1-\\epsilon\\sumh t{i,h})}{p_i}. $ This must be index by both the parent nest and commodity as commodities can appear in a netput tree multiple times, albeit not directly under the same nest.","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"The cost function, C_n, depends on the elasticity of the root. If sigma=1, the cost function is given by Cobb-Douglass $   Cn =  \\prod{i=1}^k \\pi{n,Ci}^{\\frac{qi}{q}}. $ And if sigmane1 then we use a CES cost function $ Cn =          \\left(\\sum{i=1}^k \\frac{qi}{q} \\pi{n,Ci}^{1+\\epsilon\\sigma}\\right)^{\\frac{1}{1+\\epsilon\\sigma}}. $","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"In general, these trees can be highly nested. Consider a path from the root, n_1 to a leaf n_k+1, see the Figure below.","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"<img src=\"../images/root_to_leaf.png\" height=\"25%\"/>","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"â €","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Using this we can calculate the compensated demand, CD(SCn_k), for the sector S, commodity C and nest n_k $ CD(S,C,nk) = -\\epsilon QC \\left(\\frac{C{nk}}{\\pi{nk,C}}\\right)^{-\\epsilon\\sigmak} \\prod{i=1}^{k-1} \\left(\\frac{C{ni}}{C{n{i+1}}}\\right)^{-\\epsilon\\sigma{i}}. $ Finally, the compensated demand, CD(SC), is the summation over all nests that have C as a leaf. $ CD(S,C) = \\sum{\\substack{n\\text{ nest}\\ \\text{if }(n,C)\\text{ is an edge}}} CD(S,C,n) $","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"For convenience we take any compensated demand not defined above to be 0, this follows from the empty summation in CD(SC).","category":"page"},{"location":"how_it_works/#\\tau","page":"How MPSGE Works","title":"tau","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"For sector S and consumer H define  $ \\tau(S,H) = - \\sum{\\substack{C\\in\\text{ Commodities}\\n\\in\\text{ nests}}} CD(S,C,n)\\cdot t{S,C,H,n}\\cdot C $ where t_SCHn is the tax on the commodity C by consumer H in sector S  under nest n.","category":"page"},{"location":"how_it_works/#Endowments/Demands","page":"How MPSGE Works","title":"Endowments/Demands","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"For commodity C and consumer H define E(HC) to be the endowment quantity. This is taken to be 0 if there is no endowment for H and C.","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Let q_C be the quantity of demand for commodity C in H consumer demand and q = sum_C q_C be the total demand. Define the demand function, D(HC), as $     D(H,C) = \\frac{q_C}{q}\\cdot \\frac{H}{C} $","category":"page"},{"location":"how_it_works/#Constraints","page":"How MPSGE Works","title":"Constraints","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"With these definitions, we can define the complementarity constraints. ","category":"page"},{"location":"how_it_works/#Zero-Profit","page":"How MPSGE Works","title":"Zero Profit","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Let S be a sector with a production block, then the zero profit condition is  given by, $ \\left(-\\sum{C\\in\\text{ Commodities}}CD(S,C)\\cdot C\\right) + \\sum{H\\in\\text{ Consumers}} \\tau(S,H) \\perp S. $","category":"page"},{"location":"how_it_works/#Market-Clearance","page":"How MPSGE Works","title":"Market Clearance","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Let C be a commodity, then the market clearance condition is given by, $ \\left(\\sum{S\\in\\text{ Sectors}} CD(S,C)\\cdot S \\right) - \\sum{H\\in\\text{ Consumers}} E(H,C) - D(H,C) \\perp C. $","category":"page"},{"location":"how_it_works/#Income-Balance","page":"How MPSGE Works","title":"Income Balance","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Let H be a consumer, then the income balance condition is given by, $ H - \\left(\\sum{C\\in\\text{ Commodities}} E(H,C)\\cdot C - \\sum{S\\in\\text{ Sectors}}\\tau(S,H)\\cdot S\\right) \\perp H $","category":"page"},{"location":"how_it_works/#Production-Blocks","page":"How MPSGE Works","title":"Production Blocks","text":"","category":"section"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Production blocks represent two trees: Input and output. ","category":"page"},{"location":"how_it_works/","page":"How MPSGE Works","title":"How MPSGE Works","text":"Prod: A ","category":"page"}]
}
